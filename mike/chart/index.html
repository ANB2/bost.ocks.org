<!DOCTYPE html>
<meta charset="utf-8">
<title>Towards Reusable Charts</title>
<style>

@import url(../style.css);

body > div {
  margin-left: -10px;
}

.area {
  fill: steelblue;
}

.attention {
  background: yellow;
  margin: -4px;
  padding: 4px;
}

</style>
<script src="d3.v2.js"></script>
<script src="chart.js"></script>

<h1>Towards Reusable Charts</h1>

<p>I’d like to propose a convention for encapsulating reusable charts in <a href="http://mbostock.github.com/d3/">D3</a>. Wait for it…

<pre><code>function chart() {
  // generate chart here
}</code></pre>

<aside>You could infer the dimensions from the containing element, but most
charts require some configuration.</aside>

<p>A function; the standard unit of code reuse!

<h2>Configuration</h2>

<p>I jest; not any function will do. In truth we need <span class="attention">a <i>configurable</i> function</span>, since most charts require customization of their appearance or behavior. For example, you may need to specify the width and height, or the color palette.

<p>A simple method of configuration is passing arguments:

<pre><code>function chart(width, height) {
  // generate chart here, using `width` and `height`
}</code></pre>

<p>Yet this is cumbersome for the caller: they must store the chart’s various arguments, and pass them whenever an update is needed. A simple function is insufficient for highly-configurable charts. You could try a configuration object instead, as is done by many charting libraries:

<pre><code>function chart(config) { // e.g., {width: 720, height: 80}
  // generate chart here
}</code></pre>

<p>However, the caller must still manage both the chart function (assuming you have multiple types of charts to pick from) and the configuration object. To bind the chart configuration to the chart function, we need a <a href="http://jibbering.com/faq/notes/closures/">closure</a>:

<aside>A conventional object-oriented approach as <code>Chart.&#8203;proto&shy;type.&#8203;render</code> would also work, but then you must manage the <code>this</code> context when calling the function.</aside>

<pre><code>function chart(config) {
  return function() {
    // generate chart here, using `config.width` and `config.height`
  };
}</code></pre>

<p>Now, the caller need merely say:

<pre><code>var myChart = chart({width: 720, height: 80});</pre></code>

<p>And subsequently, <code>myChart()</code> to update. Simple!

<p>But what if you want to change the configuration after construction? Or if you want to inspect the configuration of an existing chart? The configuration object is trapped by the closure and inaccessible to the outside world. Fortunately, JavaScript <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function">functions are objects</a>, so we can store configuration properties on the function itself!

<pre><code>var myChart = chart();
myChart.width = 720;
myChart.height = 80;</code></pre>

<p>The chart implementation changes slightly so that it can reference its configuration:

<aside>The inner function (<code>my</code>) can be named whatever you like; the name is only visible internally. You can even use the name <code>chart</code>, which would mask the outer function!</aside>

<pre><code>function chart() {
  return function my() {
    // generate chart here, using `my.width` and `my.height`
  };
}</code></pre>

<p>With a little bit of syntactic sugar, we can replace raw properties with getter-setter methods that allow <a href="http://en.wikipedia.org/wiki/Method_chaining">method chaining</a>. This gives the caller a more elegant way of constructing charts, and also allows the chart to manage side-effects when a configuration parameter changes. The chart may also provide default configuration values. Here we create a new chart and set two properties:

<pre><code>var myChart = chart().width(720).height(80);</code></pre>

<p>Modifying an existing chart is similarly easy:

<pre><code>myChart.height(500);</code></pre>

<p>As is inspecting it:

<pre><code>myChart.height(); // 500</code></pre>

<p>Internally, the chart implementation becomes slightly more complex to support getter-setter methods, but convenience for the user merits additional developer effort! (And besides, this pattern becomes natural after you’ve used it for a while.)

<pre><code>function chart() {
  var width = 720, // default width
      height = 80; // default height

  function my() {
    // generate chart here, using `width` and `height`
  }

  my.width = function(value) {
    if (!arguments.length) return width;
    width = value;
    return my;
  };

  my.height = function(value) {
    if (!arguments.length) return height;
    height = value;
    return my;
  };

  return my;
}</code></pre>

<p><span class="attention">To sum up: implement charts as <b>closures with getter-setter methods</b>.</span> Conveniently, this is the same pattern used by D3’s other reusable objects, including <a href="https://github.com/mbostock/d3/wiki/Scales">scales</a>, <a href="https://github.com/mbostock/d3/wiki/Layouts">layouts</a>, <a href="https://github.com/mbostock/d3/wiki/SVG-Shapes">shapes</a>, <a href="https://github.com/mbostock/d3/wiki/SVG-Axes">axes</a>, <i>etc.</i>

<h2>Implementation</h2>

<p>The chart can now be configured, but two essential ingredients are still missing: the DOM element into which to render the chart (such as a particular div or <code>document.body</code>), and the data to display. These could be considered configuration, but D3 provides a more natural representation for data and elements: the <b>selection</b>.

<p>By taking a selection as input, charts have greater flexibility. For example, you can render a chart into multiple elements simultaneously, or easily move a chart between elements without explicitly unbinding and rebinding. You can control exactly when and how the chart gets updated when data or configuration changes (for example, using a transition rather than an instantaneous update). In effect, the chart becomes a rubber stamp for rendering data visually.

<p>The simplest way of invoking our chart function on a selection, then, is to pass the selection as an argument:

<pre><code>myChart(selection);</code></pre>

<aside>From the API reference: “[call] invokes the specified function once, passing in the current selection… The call operator is identical to invoking a function by hand; but it makes it easier to use method chaining.”</aside>

<p>Or equivalently, using <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-call">selection.call</a>:

<pre><code>selection.call(myChart);</code></pre>

<p>Internally, a call-based chart implementation looks something like this:

<aside>You could also design your chart function to work directly with <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-each">selection.each</a>, but selection.call is more general and has precedent with the brush and axis components.</aside>

<pre><code>function my(selection) {
  selection.each(function(d, i) {
    // generate chart here; `d` is the data and `this` is the element
  });
}</code></pre>

<p>Next we’ll look at some examples of how to implement charts with this design.

<h2>Examples</h2>

<p>Our first chart:

<script>

d3.select("body").append("div").call(emptyChart()
    .width(720)
    .height(80));

</script>

<pre><code>d3.select("body").append("div").call(emptyChart()
    .width(720)
    .height(80));</code></pre>

<p>OK, that’s not very exciting, because our chart is empty. Here’s a slightly more interesting chart:

<script>

d3.select("body").append("div").call(marginChart()
    .margin({top: 10, right: 10, bottom: 10, left: 10})
    .width(720)
    .height(80));

</script>

<pre><code>d3.select("body").append("div").call(marginChart()
    .margin({top: 10, right: 10, bottom: 10, left: 10})
    .width(720)
    .height(80));</code></pre>

<p>Still not very exciting, because the chart is solid black. OK, how about an <i>x</i>-axis that might be used to encode quantitative values?

<script>

d3.select("body").append("div").call(axisChart()
    .margin({top: 10, right: 10, bottom: 20, left: 10})
    .width(720)
    .height(80));

</script>

<pre><code>d3.select("body").append("div").call(axisChart()
    .margin({top: 10, right: 10, bottom: 10, left: 10})
    .width(720)
    .height(80));</code></pre>

<p>Woot, now we’re getting somewhere!

<script>

d3.select("body").append("div")
    .datum([
      [0.0, 0.0], [0.1, 0.7], [0.2, 0.5], [0.3, 0.4], [0.4, 0.5],
      [0.5, 0.3], [0.6, 0.4], [0.7, 0.5], [0.8, 0.7], [0.9, 0.5],
      [1.0, 0.5]
    ])
  .call(areaChart()
    .margin({top: 10, right: 10, bottom: 20, left: 10})
    .width(720)
    .height(80));

</script>

<pre><code>d3.select("body").append("div")
    .datum([
      [0.0, 0.0], [0.1, 0.7], [0.2, 0.5], [0.3, 0.4], [0.4, 0.5],
      [0.5, 0.3], [0.6, 0.4], [0.7, 0.5], [0.8, 0.7], [0.9, 0.5],
      [1.0, 0.5]
    ])
  .call(areaChart()
    .margin({top: 10, right: 10, bottom: 20, left: 10})
    .width(720)
    .height(80));</code></pre>

<h2>Oh, and One More Thing</h2>

<p>Charts can be implemented to support transitions automatically. This allows the caller to create a transition with the desired delay, duration and easing, and the chart will smoothly animate to the new state:

<pre><code>transition.call(myChart);</code></pre>

<footer>
  <aside>February 26, 2012</aside>
  <a href="http://bost.ocks.org/mike">Mike Bostock</a>
</footer>

<script src="../highlight.min.js"></script>
