<!DOCTYPE html>
<meta charset="utf-8">
<title>How Selections Work</title>
<style>

@import url(../style.css?20130411);

.join,
.link,
.node rect {
  fill: none;
  stroke: #636363;
  stroke-width: 1.5px;
}

.node rect {
  fill: white;
}

.link path,
.node rect,
.node text,
.join {
  -webkit-transition: fill-opacity 500ms linear, stroke-opacity 500ms linear, stroke 500ms linear, fill 500ms linear;
  -moz-transition: fill-opacity 500ms linear, stroke-opacity 500ms linear, stroke 500ms linear, fill 500ms linear;
  -ms-transition: fill-opacity 500ms linear, stroke-opacity 500ms linear, stroke 500ms linear, fill 500ms linear;
  -o-transition: fill-opacity 500ms linear, stroke-opacity 500ms linear, stroke 500ms linear, fill 500ms linear;
  transition: fill-opacity 500ms linear, stroke-opacity 500ms linear, stroke 500ms linear, fill 500ms linear;
}

.node .array rect {
  stroke: #636363;
}

.node .element rect {
  fill: #bdbdbd;
  stroke: none;
}

.node .null rect {
  fill: none;
  stroke: none;
}

.node .null text {
  fill: #636363;
}

.node .function rect {
  stroke: #3182bd;
}

.node .selection rect {
  stroke: #e6550d;
}

.node .data rect {
  fill: #d9d9d9;
  stroke: none;
}

.node .code text {
  font-family: monospace;
}

.node .key rect {
  fill: #a1d99b;
  stroke: none;
}

.link .to-data {
  stroke: #ddd;
}

.link .to-element {
  stroke: #bdbdbd;
}

.link .to-key,
.join {
  stroke: #a1d99b;
}

.join {
  stroke-dasharray: 2,2;
}

.link .to-null {
  stroke-opacity: .5;
  stroke-dasharray: .5,3.5;
  stroke-linecap: round;
}

.play circle {
  fill: #fff;
  stroke: #000;
  stroke-width: 3px;
}

.play:hover path {
  fill: #f00;
}

.play.mousedown circle {
  fill: #f00;
}

.play.mousedown path {
  fill: #fff;
}

.play rect {
  fill: none;
  pointer-events: all;
  cursor: pointer;
}

</style>

<header>
  <aside>April 12, 2013</aside>
  <a href="../" rel="author">Mike Bostock</a>
</header>

<h1>How Selections Work</h1>

<blockquote>
  <q>Any sufficiently advanced technology is indistinguishable from magic.</q>
  –Arthur C. Clarke
</blockquote>

<p>In the past I have <a href="../d3/workshop/">presented</a> <a href="../join/">simplified</a> <a href="http://mbostock.github.io/d3/tutorial/circle.html">descriptions</a> of <a href="https://github.com/mbostock/d3/wiki/Selections">selections</a>, hoping to provide an informative yet quick introduction to D3’s core concept—just enough to get started. This post takes a more comprehensive approach; rather than saying how to <i>use</i> selections, I will instead explain how selections are <i>implemented</i>. This may take longer to read, but it should dispel any magic and help you master data-driven documents.

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

var margin = {top: 0, right: 40, bottom: 0, left: 40},
    width = 720,
    step = 100;

function tree(leftRoot, rightRoot, outerHeight) {
  if (arguments.length < 3) outerHeight = rightRoot, rightRoot = null;

  var height = outerHeight - margin.top - margin.bottom;

  var tree = d3.layout.tree()
      .size([height, 1])
      .separation(function() { return 1; });

  var svg = d3.select("body").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .style("margin", "1em 0 1em " + -margin.left + "px");

  var g = svg.selectAll("g")
      .data([].concat(
        leftRoot ? {type: "left", nodes: tree.nodes(leftRoot)} : [],
        rightRoot ? {type: "right", nodes: tree.nodes(rightRoot).map(flip), flipped: true} : []
      ))
    .enter().append("g")
      .attr("class", function(d) { return d.type; })
      .attr("transform", function(d) { return "translate(" + (!!d.flipped * width + margin.left) + "," + margin.top + ")"; });

  var link = g.append("g")
      .attr("class", "link")
    .selectAll("path")
      .data(function(d) { return tree.links(d.nodes); })
    .enter().append("path")
      .attr("class", linkType);

  var node = g.append("g")
      .attr("class", "node")
    .selectAll("g")
      .data(function(d) { return d.nodes; })
    .enter().append("g")
      .attr("class", function(d) { return d.type; });

  node.append("rect");

  node.append("text")
      .attr("dy", ".35em")
      .text(function(d) { return d.name; })
      .each(function(d) { d.width = Math.max(32, this.getComputedTextLength() + 12); })
      .attr("x", function(d) { return d.flipped ? 6 - d.width : 6; });

  node.filter(function(d) { return "join" in d; }).insert("path", "text")
      .attr("class", "join");

  svg.call(reset);

  function flip(d) {
    d.depth *= -1;
    d.flipped = true;
    return d;
  }

  return svg;
}

function linkType(d) {
  return d.target.type.split(/\s+/).map(function(t) { return "to-" + t; })
      .concat(d.source.type.split(/\s+/).map(function(t) { return "from-" + t; }))
      .join(" ");
}

function reset(svg) {
  svg.selectAll("*")
      .style("stroke-opacity", null)
      .style("fill-opacity", null)
      .style("display", null);

  var node = svg.selectAll(".node g")
      .attr("class", function(d) { return d.type; })
      .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.x + ")"; });

  node.select("rect")
      .attr("ry", 6)
      .attr("rx", 6)
      .attr("y", -10)
      .attr("height", 20)
      .attr("width", function(d) { return d.width; })
    .filter(function(d) { return d.flipped; })
      .attr("x", function(d) { return -d.width; });

  node.select(".join")
      .attr("d", d3.svg.diagonal()
        .source(function(d) { return {y: d.width, x: 0}; })
        .target(function(d) { return {y: 88, x: d.join * 24}; })
        .projection(function(d) { return [d.y, d.x]; }));

  svg.selectAll(".link path")
      .attr("class", linkType)
      .attr("d", d3.svg.diagonal()
        .source(function(d) { return {y: d.source.depth * step + (d.source.flipped ? -1 : +1) * d.source.width, x: d.source.x}; })
        .target(function(d) { return {y: d.target.depth * step, x: d.target.x}; })
        .projection(function(d) { return [d.y, d.x]; }));
}

function selectAllAnimation(startRoot, startHeight, endRoot, endHeight) {
  var end = tree(endRoot, endHeight).remove(),
      height = +end.attr("height"),
      start = tree(startRoot, startHeight).attr("height", height),
      svg = start.node(),
      offset = (endHeight - startHeight) / 2,
      transform = "translate(" + margin.left + "," + offset + ")";

  var play = start.append("g")
      .attr("class", "play");

  play.append("circle")
      .attr("r", 45)
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")");

  play.append("path")
      .attr("d", "M-22,-30l60,30l-60,30z")
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")scale(.7)");

  play.append("rect")
      .attr("width", width)
      .attr("height", height)
      .on("mousedown", function() {
        play.classed("mousedown", true);
        d3.select(window).on("mouseup", function() { play.classed("mousedown", false); });
      })
      .on("click", function() {
        resetAll();
        animation();
      });

  end = d3.select(svg.appendChild(end.node().firstChild));
  start = d3.select(svg.firstChild).attr("transform", transform);
  end.selectAll(".array").each(function() { this.parentNode.appendChild(this); }); // mask elements

  var startNodes = start.datum().nodes,
      startElements = startNodes.filter(function(d) { return d.type === "element"; }),
      endNodes = end.datum().nodes,
      endGroups = endNodes.filter(function(d) { return d.type === "array"; });

  resetAll();

  function resetAll() {
    start.style("display", "none").call(reset);
    end.style("display", null).call(reset);
    play.style("display", null);
  }

  function animation() {
    start.call(fadeIn, 150);
    end.style("display", "none");
    play.style("display", "none");
    setTimeout(transition1, 1250);
  }

  function transition1() {
    var t = start.transition()
        .duration(1000 + (startElements.length - 1) * 50)
        .each("end", transition2);

    t.selectAll(".selection,.array,.link")
        .duration(0)
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    t.selectAll(".element")
        .duration(500)
        .delay(function(d, i) { return 500 + i * 50; })
        .attr("transform", function(d, i) { return "translate(" + (d.depth - 1) * step + "," + (endGroups[i].x - offset) + ")"; })
        .attr("class", "array")
      .select("rect")
        .attr("width", function(d, i) { return endGroups[i].width; });
  }

  function transition2() {
    end.style("display", null)
      .selectAll(".element,.to-element")
        .style("display", "none");

    end.selectAll(".selection,.to-array,.array")
        .call(fadeIn);

    end.transition()
        .duration(500)
        .each("end", transition3);
  }

  function transition3() {
    start.style("display", "none");

    end.selectAll(".element")
        .style("display", null)
        .attr("transform", function(d) { return "translate(" + d.parent.depth * step + "," + d.parent.x + ")"; })
      .transition()
        .duration(500)
        .delay(function(d, i) { return i * 50; })
        .attr("transform", function(d) { return "translate(" + d.depth * step + "," + d.x + ")"; });

    end.selectAll(".to-element")
        .style("display", null)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d, i) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .projection(function(d) { return [d.y, d.x]; }))
      .transition()
        .duration(500)
        .delay(function(d, i) { return i * 50; })
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d, i) { return {y: d.target.depth * step, x: d.target.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    end.transition()
        .duration(2000)
        .each("end", resetAll);
  }
}

function updateAnimation(leftRoot, rightRoot, endRoot, outerHeight) {
  var start = tree(leftRoot, rightRoot, outerHeight),
      left = d3.select(start.node().firstChild),
      right = d3.select(left.node().nextSibling),
      end = tree(endRoot, outerHeight).remove(),
      height = +start.attr("height");

  end = d3.select(start.node().appendChild(end.node().firstChild));
  left.selectAll(".element").each(function() { this.parentNode.appendChild(this); }); // mask keys
  right.selectAll(".data").each(function() { this.parentNode.appendChild(this); }); // mask keys
  start.node().appendChild(left.node());
  start.node().appendChild(right.node());

  var leftKeys = left.datum().nodes.filter(function(d) { return d.type === "key"; }),
      rightKeys = right.datum().nodes.filter(function(d) { return d.type === "key"; }),
      endElements = end.datum().nodes.filter(function(d) { return d.parent && d.parent.type === "array"; });

  leftKeys.forEach(function(l, i) {
    if ("join" in l) {
      rightKeys[i + l.join].joined = true;
      endElements[i + l.join].start = l.parent;
      l.parent.end = endElements[i + l.join];
    }
  });

  leftKeys.forEach(function(l, i) {
    if (!("join" in l)) endElements.some(function(e) {
      if (!e.start) {
        e.start = l.parent;
        l.parent.end = e;
        return true;
      }
    });
  });

  var play = start.append("g")
      .attr("class", "play");

  play.append("circle")
      .attr("r", 45)
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")");

  play.append("path")
      .attr("d", "M-22,-30l60,30l-60,30z")
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")scale(.7)");

  play.append("rect")
      .attr("width", width)
      .attr("height", height)
      .on("mousedown", function() {
        play.classed("mousedown", true);
        d3.select(window).on("mouseup", function() { play.classed("mousedown", false); });
      })
      .on("click", function() {
        resetAll();
        animation();
      });

  resetAll();

  function resetAll() {
    play.style("display", null);
    left.style("display", "none").call(reset);
    right.style("display", "none").call(reset);
    right.selectAll(".key").classed("joined", function(d) { return d.joined; });
    right.selectAll(".data").classed("joined", function(d) { return d.children[0].joined; });
    right.selectAll(".to-key").classed("joined", function(d) { return d.target.joined; });
    end.call(reset);
  }

  function animation() {
    play.style("display", "none");
    end.style("display", "none");
    left.call(fadeIn);
    right.call(fadeIn);
    setTimeout(transition1, 1250);
  }

  function transition1() {
    left.selectAll(".key").filter(function(d) { return !("join" in d); })
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    left.selectAll(".to-key").filter(function(d) { return !("join" in d.target); })
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    left.selectAll(".element").filter(function(d) { return !("join" in d.children[0]); })
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    left.selectAll(".to-element").filter(function(d) { return !("join" in d.target.children[0]); })
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    right.selectAll(".link > :not(.joined),.node > :not(.joined)")
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    end.style("display", null);

    end.selectAll(".data,.to-data")
        .style("display", "none");

    end.selectAll(".element,.null")
        .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.start.x + ")"; });

    end.selectAll(".to-element,.to-null")
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: d.target.depth * step, x: d.target.start.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    setTimeout(transition2, 500);
  }

  function transition2() {
    left.selectAll(".element").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.end.x + ")"; });

    left.selectAll(".key").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.parent.end.x + ")"; });

    left.selectAll(".to-element").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: d.target.depth * step, x: d.target.end.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    left.selectAll(".to-key").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.end.x}; })
          .target(function(d) { return {y: d.target.depth * step, x: d.target.parent.end.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    left.selectAll(".join").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.width, x: 0}; })
          .target(function(d) { return {y: 88, x: 0}; })
          .projection(function(d) { return [d.y, d.x]; }));

    end.selectAll(".element,.null").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + d.depth * step + "," + d.x + ")"; });

    end.selectAll(".to-element,.to-null").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: d.target.depth * step, x: d.target.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    setTimeout(transition3, 500);
  }

  function transition3() {
    var offset = 12;

    left.selectAll(".join").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: d.width, x: 0}; })
          .target(function(d) { return {y: d.width, x: 0}; })
          .projection(function(d) { return [d.y, d.x]; }));

    left.selectAll(".to-key")
        .attr("class", "from-element to-data");

    right.selectAll(".to-key").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: (d.source.depth - 2) * step + offset - d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: (d.source.depth - 2) * step + offset - d.source.width, x: d.source.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    right.selectAll(".key").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + ((d.depth - 1) * step + offset) + "," + d.x + ")"; });

    right.selectAll(".data").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + ((d.depth - 2) * step + offset) + "," + d.x + ")"; });

    setTimeout(resetAll, 2000);
  }
}

function exitAnimation(leftRoot, rightRoot, endRoot, outerHeight) {
  var start = tree(leftRoot, rightRoot, outerHeight),
      left = d3.select(start.node().firstChild),
      right = d3.select(left.node().nextSibling),
      end = tree(endRoot, outerHeight).remove(),
      height = +start.attr("height");

  end = d3.select(start.node().appendChild(end.node().firstChild));
  start.node().appendChild(left.node());
  start.node().appendChild(right.node());

  var play = start.append("g")
      .attr("class", "play");

  play.append("circle")
      .attr("r", 45)
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")");

  play.append("path")
      .attr("d", "M-22,-30l60,30l-60,30z")
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")scale(.7)");

  play.append("rect")
      .attr("width", width)
      .attr("height", height)
      .on("mousedown", function() {
        play.classed("mousedown", true);
        d3.select(window).on("mouseup", function() { play.classed("mousedown", false); });
      })
      .on("click", function() {
        resetAll();
        animation();
      });

  resetAll();

  function resetAll() {
    play.style("display", null);
    left.style("display", "none").call(reset);
    right.style("display", "none").call(reset);
    end.call(reset);
  }

  function animation() {
    play.style("display", "none");
    end.style("display", "none");
    left.call(fadeIn);
    right.call(fadeIn);
    setTimeout(transition1, 1250);
  }

  function transition1() {
    end.style("display", null);

    left
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    right
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    setTimeout(resetAll, 2000);
  }
}

function enterAnimation(leftRoot, rightRoot, endRoot, outerHeight) {
  var start = tree(leftRoot, rightRoot, outerHeight),
      left = d3.select(start.node().firstChild),
      right = d3.select(left.node().nextSibling),
      end = tree(endRoot, outerHeight).remove(),
      height = +start.attr("height");

  start.node().appendChild(left.node());
  start.node().appendChild(right.node());
  end = d3.select(start.node().appendChild(end.node().firstChild));

  var leftKeys = left.datum().nodes.filter(function(d) { return d.type === "key"; }),
      rightKeys = right.datum().nodes.filter(function(d) { return d.type === "key"; });

  leftKeys.forEach(function(l, i) {
    if ("join" in l) {
      rightKeys[i + l.join].joined = true;
    }
  });

  var play = start.append("g")
      .attr("class", "play");

  play.append("circle")
      .attr("r", 45)
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")");

  play.append("path")
      .attr("d", "M-22,-30l60,30l-60,30z")
      .attr("transform", "translate(" + (margin.left + width / 2) + "," + height / 2 + ")scale(.7)");

  play.append("rect")
      .attr("width", width)
      .attr("height", height)
      .on("mousedown", function() {
        play.classed("mousedown", true);
        d3.select(window).on("mouseup", function() { play.classed("mousedown", false); });
      })
      .on("click", function() {
        resetAll();
        animation();
      });

  resetAll();

  function resetAll() {
    play.style("display", null);
    left.style("display", "none").call(reset);
    right.style("display", "none").call(reset);
    right.selectAll(".key").classed("joined", function(d) { return d.joined; });
    right.selectAll(".data").classed("joined", function(d) { return d.children[0].joined; });
    right.selectAll(".to-key").classed("joined", function(d) { return d.target.joined; });
    end.call(reset);
  }

  function animation() {
    play.style("display", "none");
    end.style("display", "none");
    left.call(fadeIn);
    right.call(fadeIn);
    setTimeout(transition1, 1250);
  }

  function transition1() {
    end.style("display", null);

    end.selectAll(".element,.data,.to-data")
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    left.selectAll(".element,.to-element,.key,.to-key")
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    right.selectAll(".array,.to-array,.function,.to-function,.to-data,.joined")
        .style("stroke-opacity", 0)
        .style("fill-opacity", 0);

    setTimeout(transition2, 750);
  }

  function transition2() {
    var offset = 12;

    right.selectAll(".key:not(.joined)").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + ((d.depth - 2) * step + offset) + "," + d.x + ")"; });

    right.selectAll(".data:not(.joined)").transition()
        .duration(500)
        .attr("transform", function(d, i) { return "translate(" + ((d.depth - 2) * step + offset) + "," + d.x + ")"; });

    right.selectAll(".to-key:not(.joined)").transition()
        .duration(500)
        .attr("d", d3.svg.diagonal()
          .source(function(d) { return {y: (d.source.depth - 2) * step + offset - d.source.width, x: d.source.x}; })
          .target(function(d) { return {y: (d.source.depth - 3) * step + offset - d.source.width, x: d.source.x}; })
          .projection(function(d) { return [d.y, d.x]; }));

    setTimeout(transition3, 500);
  }

  function transition3() {
    right.selectAll(".to-key:not(.joined)")
        .style("stroke-opacity", 0);

    end.selectAll(".element,.data,.to-data")
        .style("stroke-opacity", 1)
        .style("fill-opacity", 1);

    setTimeout(resetAll, 2000);
  }
}

function fadeIn(selection, delay) {
  selection
      .style("display", null)
      .style("stroke-opacity", 0)
      .style("fill-opacity", 0)
    .transition()
      .duration(delay || 0)
      .style("stroke-opacity", 1)
      .style("fill-opacity", 1);
}

</script>

<h2><a href="#subclass" name="subclass">#</a>A Subclass of Array</h2>

<aside>JavaScript doesn’t yet support array subclasses directly, so arrays are subclassed through <a href="http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/">prototype chain injection</a>.</aside>

<p>You were probably told that selections are arrays of DOM elements. This is technically true, but imprecise. Selections are a <i>subclass</i> of array; this subclass provides methods to manipulate selected elements, such as setting attributes and styles. Selections inherit native array methods as well, such as <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach">array.forEach</a> and <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach">array.map</a>. However, you won’t often use native methods as D3 provides convenient alternatives, such as <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-each">selection.each</a>. (A few native methods are overridden to adapt their behavior to selections, namely <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-filter">selection.filter</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-sort">selection.sort</a>.)

<h2><a href="#group" name="group">#</a>Groups of Elements</h2>

<p>The other reason selections aren’t arrays of elements is that they are actually <i>arrays of arrays</i> of elements. A selection is an array of groups, and each group is an array of elements. For example, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_select">d3.select</a> returns a selection with one group containing the selected element:

<aside>This is why you’ll sometimes see <code>selection[0][0]</code> to refer to the first node, although for reasons that will soon be apparent it’s more robust to use <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-node">selection.node</a>.</aside>

<pre><code>d3.select("table");</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "table₀"}
    ]}
  ]},
  24 * 1
);

</script>

<p>Likewise, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_selectAll">d3.selectAll</a> returns a selection with one group and any number of elements:

<aside>While the selection is a subclass of array, groups are plain arrays. They do, however, have a <code>parentNode</code> property which stores the shared ancestor (here the <a href="https://developer.mozilla.org/en-US/docs/DOM/document.documentElement">document element</a>) of the group’s elements.</aside>

<pre><code>d3.selectAll("tr");</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "tr₀"},
      {type: "element", name: "tr₁"},
      {type: "element", name: "tr₂"},
      {type: "element", name: "tr₃"}
    ]}
  ]},
  24 * 4
);

</script>

<p>Selections returned by d3.select and d3.selectAll have exactly one group. The only way you to obtain a selection with multiple groups is <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-selectAll">selection.selectAll</a>. For example, if you select all table rows and then select the rows’ cells, you’ll get a group of sibling cells for each row:

<pre><code>d3.selectAll("tr")<span id="select-all-1">.selectAll("td")</span>;</code></pre>

<aside>Although this selection’s groups all have four elements, in general a selection’s groups can have different numbers of elements. Some groups might even be empty!</aside>

<!-- TODO Highlight the relevant part of the code during the animation. -->

<script>

selectAllAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "tr₀"},
      {type: "element", name: "tr₁"},
      {type: "element", name: "tr₂"},
      {type: "element", name: "tr₃"}
    ]}
  ]},
  24 * 4,
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "td₀"},
      {type: "element", name: "td₁"},
      {type: "element", name: "td₂"},
      {type: "element", name: "td₃"}
    ]},
    {type: "array", name: "group₁", children: [
      {type: "element", name: "td₄"},
      {type: "element", name: "td₅"},
      {type: "element", name: "td₆"},
      {type: "element", name: "td₇"}
    ]},
    {type: "array", name: "group₂", children: [
      {type: "element", name: "td₈"},
      {type: "element", name: "td₉"},
      {type: "element", name: "td₁₀"},
      {type: "element", name: "td₁₁"}
    ]},
    {type: "array", name: "group₃", children: [
      {type: "element", name: "td₁₂"},
      {type: "element", name: "td₁₃"},
      {type: "element", name: "td₁₄"},
      {type: "element", name: "td₁₅"}
    ]}
  ]},
  24 * 16
);

</script>

<p>With selectAll, <b>every element in the old selection becomes a group in the new selection</b>. Each group contains an old element’s matching descendant elements. So, if each table cell contained a <a href="https://developer.mozilla.org/en-US/docs/HTML/Element/span">span</a> element, and you called selectAll a third time, you’d get a selection with sixteen groups:

<pre><code>d3.selectAll("tr").selectAll("td").selectAll("span");</code></pre>

<aside>It’s only selectAll that has this special behavior regarding grouping. <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-select">Select</a>, in contrast, preserves the grouping because there is exactly one element (or null) in the new selection for each element in the old selection.</aside>

<script>

selectAllAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "td₀"},
      {type: "element", name: "td₁"},
      {type: "element", name: "td₂"},
      {type: "element", name: "td₃"}
    ]},
    {type: "array", name: "group₁", children: [
      {type: "element", name: "td₄"},
      {type: "element", name: "td₅"},
      {type: "element", name: "td₆"},
      {type: "element", name: "td₇"}
    ]},
    {type: "array", name: "group₂", children: [
      {type: "element", name: "td₈"},
      {type: "element", name: "td₉"},
      {type: "element", name: "td₁₀"},
      {type: "element", name: "td₁₁"}
    ]},
    {type: "array", name: "group₃", children: [
      {type: "element", name: "td₁₂"},
      {type: "element", name: "td₁₃"},
      {type: "element", name: "td₁₄"},
      {type: "element", name: "td₁₅"}
    ]}
  ]},
  24 * 16,
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₁", children: [{type: "element", name: "span₁"}]},
    {type: "array", name: "group₂", children: [{type: "element", name: "span₂"}]},
    {type: "array", name: "group₃", children: [{type: "element", name: "span₃"}]},
    {type: "array", name: "group₄", children: [{type: "element", name: "span₄"}]},
    {type: "array", name: "group₅", children: [{type: "element", name: "span₅"}]},
    {type: "array", name: "group₆", children: [{type: "element", name: "span₆"}]},
    {type: "array", name: "group₇", children: [{type: "element", name: "span₇"}]},
    {type: "array", name: "group₈", children: [{type: "element", name: "span₈"}]},
    {type: "array", name: "group₉", children: [{type: "element", name: "span₉"}]},
    {type: "array", name: "group₁₀", children: [{type: "element", name: "span₁₀"}]},
    {type: "array", name: "group₁₁", children: [{type: "element", name: "span₁₁"}]},
    {type: "array", name: "group₁₂", children: [{type: "element", name: "span₁₂"}]},
    {type: "array", name: "group₁₃", children: [{type: "element", name: "span₁₃"}]},
    {type: "array", name: "group₁₄", children: [{type: "element", name: "span₁₄"}]},
    {type: "array", name: "group₁₅", children: [{type: "element", name: "span₁₅"}]}
  ]},
  24 * 16
);

</script>

<aside>For more examples, pop open the JavaScript console with <span style="font-family:'Lucida Grande';">⌥⌘J</span> and experiment! You can also read more about grouping in my previous tutorial on <a href="../nest/">nested selections</a>.</aside>

<p>Most of the time, you can ignore that selections are grouped. When you pass a function to <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-attr">attr</a> or <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-style">style</a>, the function is called for each element; the only difference with grouping is that the second argument to your function (<code>i</code>) is the within-group index rather than the within-selection index. The killer feature for groups is <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>, which allows you to define data per-group (rather than for the entire selection), and thus more easily create hierarchical DOM elements from hierarchical data. We’ll revisit this topic when we get to data joins.

<h2><a href="#null" name="null">#</a>Null Elements</h2>

<!-- TODO Reorder this section to talk about nulls at the beginning. -->

<p>Sometimes it’s useful to derive a new selection from the current selection while retaining the existing grouping. An example of this is <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-append">selection.append</a>, which appends a new element to each selected element. For example, if the document has four sections, and we select them all:

<pre><code>d3.selectAll("section");</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "section₀"},
      {type: "element", name: "section₁"},
      {type: "element", name: "section₂"},
      {type: "element", name: "section₃"}
    ]}
  ]},
  24 * 4
);

</script>

<p>If we then append a paragraph element to each section, the returned selection still has only a single group containing four elements:

<pre><code>d3.selectAll("section").append("p");</code></pre>

<aside>Because the grouping was preserved, the <code>parentNode</code> of this selection is the same as before: the document element.</aside>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀"},
      {type: "element", name: "p₁"},
      {type: "element", name: "p₂"},
      {type: "element", name: "p₃"}
    ]}
  ]},
  24 * 4
);

</script>

<p>The <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-select">selection.select</a> method functions the same way. In fact, if you read the source, you’ll see <a href="https://github.com/mbostock/d3/blob/master/src/selection/append.js">append</a> and <a href="https://github.com/mbostock/d3/blob/master/src/selection/insert.js">insert</a> are just simple wrappers on top of select! Yet there’s a difference: while append creates a new element, select must find a matching element. Sometimes, there is no such element; in this case, the returned selection has null elements. For example, if only the last two sections have asides, we might see:

<pre><code>d3.selectAll("section").select("aside");</code></pre>

<aside>Here, selection.node would return <code>selection[0][2]</code>, because this aside is the first non-null element.</aside>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "null", name: "null"},
      {type: "null", name: "null"},
      {type: "element", name: "aside₀"},
      {type: "element", name: "aside₁"}
    ]}
  ]},
  24 * 4
);

</script>

<p>Null elements are ignored for most operations. For example, D3 skips over any null elements when applying styles and attributes. Yet null elements serve an important purpose in preserving the grouped structure of a selection (and the within-group index). This is critical when handling the result of a data join, which splits a selection into three parts: <i>enter</i>, <i>update</i> and <i>exit</i>. These three selections share the original selection’s structure, with null elements in-between.

<h2><a href="#data" name="data">#</a>Bound to Data</h2>

<p>Perhaps surprisingly, data is <i>not</i> a property of the selection, but a property of its elements. This means that when you bind data a selection, the data is stored in the DOM rather than in the selection: data is assigned to the <code>__data__</code> property of each element. If an element lacks this property, the associated datum is undefined. Selections are therefore transient: you can reselect elements from the DOM and they will retain whatever data was previously bound to them.

<aside>To verify that data is a property of elements, see <a href="https://github.com/mbostock/d3/blob/master/src/selection/datum.js">selection.datum</a>’s implementation.</aside>

<p>Data is bound to elements one of several ways:<ul>

  <li>Inherited from a parent via append, insert, or select.
  <li>Assigned to individual elements via <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-datum">selection.datum</a>.
  <li>Joined to groups of elements via <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>.

</ul>

<p>There’s no reason to set the <code>__data__</code> property directly when you can use selection.datum, but doing so illustrates how data binding is implemented:

<aside>You might also find this knowledge useful when inspecting selections in your browser’s developer tools; <code>$0.__data__</code> shows the data bound to the inspected element.</aside>

<pre><code>document.body.__data__ = 42;</code></pre>

<script>

tree(
  {type: "element", name: "body₀", children: [
    {type: "code data", name: "42"}
  ]},
  24 * 1
);

</script>

<p>The D3-idiomatic equivalent is to select the body and call datum:

<pre><code>d3.select("body").datum(42);</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "body₀", children: [
        {type: "code data", name: "42"}
      ]}
    ]}
  ]},
  24 * 1
);

</script>

<p>If we now append an element to the body, the child automatically inherits data from the parent:

<pre><code>d3.select("body").datum(42).append("h1");</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "h1₀", children: [
        {type: "code data", name: "42"}
      ]}
    ]}
  ]},
  24 * 1
);

</script>

<p>And that brings us to the last method of binding data: the mysterious join! But before we can achieve enlightenment, we first need to answer a more existential question.

<h2><a href="#data" name="data">#</a>What is Data?</h2>

<p>Data in D3 can be any array of values. For example, an array of numbers:

<pre><code>var data = [4, 5, 18, 23, 42];</code></pre>

<p>Or an array of objects:

<aside>One of <a href="http://alignedleft.com">Scott Murray</a>’s many tutorials covers <a href="http://alignedleft.com/tutorials/d3/data-types/">common types of data</a> in JavaScript.</aside>

<pre><code>var data = [
  {letter: "A", frequency: .08167},
  {letter: "B", frequency: .01492},
  {letter: "C", frequency: .02780},
  {letter: "D", frequency: .04253},
  {letter: "E", frequency: .12702},
  {letter: "F", frequency: .02288},
  {letter: "G", frequency: .02022},
  {letter: "H", frequency: .06094},
  …
];</code></pre>

<p>Even an array of arrays:

<pre><code>var matrix = [
  [ 0,  1,  2,  3],
  [ 4,  5,  6,  7],
  [ 8,  9, 10, 11],
  [12, 13, 14, 15],
];</code></pre>

<p>For this document, we’ll mirror the visual representation of selections to represent data. Here’s a plain array of five numbers:

<script>

tree(
  null,
  {type: "array", name: "array", children: [
    {type: "code data", name: "4"},
    {type: "code data", name: "5"},
    {type: "code data", name: "18"},
    {type: "code data", name: "23"},
    {type: "code data", name: "42"}
  ]},
  24 * 5
);

</script>

<p>Like other selection methods, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a> accepts a function as a well as a constant value. This function is called once per group, returning the array of data for each group. Thus, just as selections are <a href="#group">grouped</a>, data can be grouped as well, by specifing a function that returns the appropriate array of data for a given group.

<aside>Your data function is passed the data bound to the group’s parent node. Thus, it is common to express child data as a function of parent data. For nested arrays of data, like the <code>matrix</code> above, the identity function is frequently used.</aside>

<script>

tree(
  null,
  {type: "function", name: "function", children: [
    {type: "array", name: "array", children: [
      {type: "code data", name: "0"},
      {type: "code data", name: "1"},
      {type: "code data", name: "2"},
      {type: "code data", name: "3"}
    ]},
    {type: "array", name: "array", children: [
      {type: "code data", name: "4"},
      {type: "code data", name: "5"},
      {type: "code data", name: "6"},
      {type: "code data", name: "7"}
    ]},
    {type: "array", name: "array", children: [
      {type: "code data", name: "8"},
      {type: "code data", name: "9"},
      {type: "code data", name: "10"},
      {type: "code data", name: "11"}
    ]},
    {type: "array", name: "array", children: [
      {type: "code data", name: "12"},
      {type: "code data", name: "13"},
      {type: "code data", name: "14"},
      {type: "code data", name: "15"}
    ]}
  ]},
  24 * 16
);

</script>

<p>For selections with only a single group, you can pass the corresponding single array to selection.data directly. You only need a function when binding data to selections with multiple groups.

<h2><a href="#key" name="key">#</a>The Key to Enlightenment</h2>

<p>The first step to the data join is identifying which datum should be assigned to which element. This is done by computing a key for each data and element. A <i>key</i> is simply an identifying string, such as a name; when the key for a datum and an element are the same, the datum is assigned to that element.

<p>The simplest method of assigning keys is by index: the first datum and the first element have the key “0”, the second datum and element have the key “1”, and so on. Joining an array of numbers to a matching array of paragraph elements therefore looks like this, with keys shown in green:

<pre><code>function key(d, i) {
  return i;
}</code></pre>

<aside><a href="http://macwright.org/">Tom MacWright</a>’s “fun, difficult” <a href="http://macwright.org/presentations/dcjq/">introduction to D3</a> explains <a href="http://macwright.org/mistakes/#5010465" style="white-space:nowrap;">data joins</a> by way of a simple reimplementation.</aside>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀", children: [{type: "key", name: "0", join: 0}]},
      {type: "element", name: "p₁", children: [{type: "key", name: "1", join: 0}]},
      {type: "element", name: "p₂", children: [{type: "key", name: "2", join: 0}]},
      {type: "element", name: "p₃", children: [{type: "key", name: "3", join: 0}]},
      {type: "element", name: "p₄", children: [{type: "key", name: "4", join: 0}]}
    ]}
  ]},
  {type: "function", name: "function", children: [
    {type: "array", name: "array", children: [
      {type: "code data", name: "4", children: [{type: "key", name: "0"}]},
      {type: "code data", name: "5", children: [{type: "key", name: "1"}]},
      {type: "code data", name: "18", children: [{type: "key", name: "2"}]},
      {type: "code data", name: "23", children: [{type: "key", name: "3"}]},
      {type: "code data", name: "42", children: [{type: "key", name: "4"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p>The resulting selection now has elements bound to data:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀", children: [{type: "code data", name: "4"}]},
      {type: "element", name: "p₁", children: [{type: "code data", name: "5"}]},
      {type: "element", name: "p₂", children: [{type: "code data", name: "18"}]},
      {type: "element", name: "p₃", children: [{type: "code data", name: "23"}]},
      {type: "element", name: "p₄", children: [{type: "code data", name: "42"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p>Joining by index is convenient if your data and elements are in the same order. However, this is not always the case! To rebind data while maintainining <a href="../constancy/">object constancy</a>, joining by index is insufficient; instead, specify a key function as the second argument to selection.data. The key function returns the key for a given datum or element. For example, if your data is an array of objects, each with a <code>letter</code> property, your key function can return the associated letter:

<aside>The key function is called for each old element and each new data: ten times in this example. The previously-bound data is used to compute old keys, while the new data is used to compute new keys.</aside>

<pre><code>function key(d) {
  return d.letter;
}</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "g₀", children: [{type: "key", name: "E", join: 1}]},
      {type: "element", name: "g₁", children: [{type: "key", name: "A", join: -1}]},
      {type: "element", name: "g₂", children: [{type: "key", name: "O", join: 1}]},
      {type: "element", name: "g₃", children: [{type: "key", name: "I", join: -1}]},
      {type: "element", name: "g₄", children: [{type: "key", name: "U", join: 0}]}
    ]}
  ]},
  {type: "function", name: "function", children: [
    {type: "array", name: "array", children: [
      {type: "code data", name: "{letter: \"A\"}", children: [{type: "key", name: "A"}]},
      {type: "code data", name: "{letter: \"E\"}", children: [{type: "key", name: "E"}]},
      {type: "code data", name: "{letter: \"I\"}", children: [{type: "key", name: "I"}]},
      {type: "code data", name: "{letter: \"O\"}", children: [{type: "key", name: "O"}]},
      {type: "code data", name: "{letter: \"U\"}", children: [{type: "key", name: "U"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p>Again, the resulting selection has elements bound to data. The elements have also been reordered within the selection to match the bound data:

<aside>Although the selection now matches the data, the elements are <i>not</i> automatically reordered in the DOM. For that you must call <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-order">selection.order</a> or <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-sort">selection.sort</a>.</aside>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "g₁", children: [{type: "code data", name: "{letter: \"A\"}"}]},
      {type: "element", name: "g₀", children: [{type: "code data", name: "{letter: \"E\"}"}]},
      {type: "element", name: "g₃", children: [{type: "code data", name: "{letter: \"I\"}"}]},
      {type: "element", name: "g₂", children: [{type: "code data", name: "{letter: \"O\"}"}]},
      {type: "element", name: "g₄", children: [{type: "code data", name: "{letter: \"U\"}"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p>This process can be quite complicated for large grouped selections, but is simplified somewhat because each group is joined independently. Thus, you only need to worry about unique keys within a group, not across the entire selection.

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀", children: [{type: "key", name: "α", join: 1}]},
      {type: "element", name: "p₁", children: [{type: "key", name: "β", join: 1}]},
      {type: "element", name: "p₂", children: [{type: "key", name: "γ", join: 1}]},
      {type: "element", name: "p₃", children: [{type: "key", name: "δ", join: -3}]}
    ]},
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₄", children: [{type: "key", name: "ε", join: 0}]},
      {type: "element", name: "p₅", children: [{type: "key", name: "ζ", join: 0}]},
      {type: "element", name: "p₆", children: [{type: "key", name: "η", join: 1}]},
      {type: "element", name: "p₇", children: [{type: "key", name: "θ", join: -1}]}
    ]},
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₈", children: [{type: "key", name: "ι", join: 0}]},
      {type: "element", name: "p₉", children: [{type: "key", name: "κ", join: +2}]},
      {type: "element", name: "p₁₀", children: [{type: "key", name: "λ", join: 0}]},
      {type: "element", name: "p₁₁", children: [{type: "key", name: "μ", join: -2}]}
    ]},
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₁₂", children: [{type: "key", name: "ν", join: +2}]},
      {type: "element", name: "p₁₃", children: [{type: "key", name: "ξ", join: +2}]},
      {type: "element", name: "p₁₄", children: [{type: "key", name: "ο", join: -2}]},
      {type: "element", name: "p₁₅", children: [{type: "key", name: "π", join: -2}]}
    ]}
  ]},
  {type: "function", name: "function", children: [
    {type: "array", name: "array", children: [
      {type: "code data", name: "{…}", children: [{type: "key", name: "δ"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "α"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "β"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "γ"}]}
    ]},
    {type: "array", name: "array", children: [
      {type: "code data", name: "{…}", children: [{type: "key", name: "ε"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "ζ"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "θ"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "η"}]}
    ]},
    {type: "array", name: "array", children: [
      {type: "code data", name: "{…}", children: [{type: "key", name: "ι"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "μ"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "λ"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "κ"}]}
    ]},
    {type: "array", name: "array", children: [
      {type: "code data", name: "{…}", children: [{type: "key", name: "ο"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "π"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "ν"}]},
      {type: "code data", name: "{…}", children: [{type: "key", name: "ξ"}]}
    ]}
  ]},
  24 * 16
);

</script>

<aside>You can read more about key functions in my previous tutorial on <a href="../constancy/">object constancy</a>.</aside>

<p>The above examples assume an exact 1:1 match between data and elements. But what happens when there’s no matching element for a given datum, or no matching datum for a given element?

<h2><a href="#enter-update-exit" name="enter-update-exit">#</a>Enter, Update and Exit</h2>

<p>When joining elements to data by key, there are three possible logical outcomes:<ul>

  <li><i>Update</i> - There was a matching element for a given datum.
  <li><i>Enter</i> - There was no matching element for a given datum.
  <li><i>Exit</i> - There was no matching datum for a given element.

</ul>

<p>These are the three selections returned by <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-enter">selection.enter</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-exit">selection.exit</a>, respectively. To illustrate, imagine you had a bar chart of the first five letters of the alphabet (ABCDE), and you want to transition to your five favorite vowels (YEAOI). You could use a key function to maintain association of letters to bars across the transition, resulting in the following data join:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "element₀", children: [{type: "key", name: "A", join: 2}]},
      {type: "element", name: "element₁", children: [{type: "key", name: "B"}]},
      {type: "element", name: "element₂", children: [{type: "key", name: "C"}]},
      {type: "element", name: "element₃", children: [{type: "key", name: "D"}]},
      {type: "element", name: "element₄", children: [{type: "key", name: "E", join: -3}]}
    ]}
  ]},
  {type: "function", name: "function", children: [
    {type: "array", name: "array", children: [
      {type: "data", name: "Y", children: [{type: "key", name: "Y"}]},
      {type: "data", name: "E", children: [{type: "key", name: "E"}]},
      {type: "data", name: "A", children: [{type: "key", name: "A"}]},
      {type: "data", name: "O", children: [{type: "key", name: "O"}]},
      {type: "data", name: "I", children: [{type: "key", name: "I"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p>Two of the previously-displayed letters (A and E) are vowels. These bars are therefore placed in the <b>update</b> selection, in order of the new data:

<aside>The enter and update selections match the order of the new dataset. The exit selection, however, preserves the order of the old selection.</aside>

<script>

updateAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "element₀", children: [{type: "key", name: "A", join: 2}]},
      {type: "element", name: "element₁", children: [{type: "key", name: "B"}]},
      {type: "element", name: "element₂", children: [{type: "key", name: "C"}]},
      {type: "element", name: "element₃", children: [{type: "key", name: "D"}]},
      {type: "element", name: "element₄", children: [{type: "key", name: "E", join: -3}]}
    ]}
  ]},
  {type: "function", name: "function", children: [
    {type: "array", name: "array", children: [
      {type: "data", name: "Y", children: [{type: "key", name: "Y"}]},
      {type: "data", name: "E", children: [{type: "key", name: "E"}]},
      {type: "data", name: "A", children: [{type: "key", name: "A"}]},
      {type: "data", name: "O", children: [{type: "key", name: "O"}]},
      {type: "data", name: "I", children: [{type: "key", name: "I"}]}
    ]}
  ]},
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "null", name: "null"},
      {type: "element", name: "element₄", children: [{type: "data", name: "E"}]},
      {type: "element", name: "element₀", children: [{type: "data", name: "A"}]},
      {type: "null", name: "null"},
      {type: "null", name: "null"}
    ]}
  ]},
  24 * 5
);

</script>

<p>The other three displayed letters (B, C and D) are consonants, and thus have no corresponding data in the new dataset. These elements are therefore placed in the <b>exit</b> selection. Note that the exit selection preserves the order of the original selection, which is sometimes useful when animating prior to removal:

<script>

exitAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "element₀", children: [{type: "key", name: "A", join: 2}]},
      {type: "element", name: "element₁", children: [{type: "key", name: "B"}]},
      {type: "element", name: "element₂", children: [{type: "key", name: "C"}]},
      {type: "element", name: "element₃", children: [{type: "key", name: "D"}]},
      {type: "element", name: "element₄", children: [{type: "key", name: "E", join: -3}]}
    ]}
  ]},
  {type: "function", name: "function", children: [
    {type: "array", name: "array", children: [
      {type: "data", name: "Y", children: [{type: "key", name: "Y"}]},
      {type: "data", name: "E", children: [{type: "key", name: "E"}]},
      {type: "data", name: "A", children: [{type: "key", name: "A"}]},
      {type: "data", name: "O", children: [{type: "key", name: "O"}]},
      {type: "data", name: "I", children: [{type: "key", name: "I"}]}
    ]}
  ]},
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "null", name: "null"},
      {type: "element", name: "element₁", children: [{type: "data", name: "B"}]},
      {type: "element", name: "element₂", children: [{type: "data", name: "C"}]},
      {type: "element", name: "element₃", children: [{type: "data", name: "D"}]},
      {type: "null", name: "null"}
    ]}
  ]},
  24 * 5
);

</script>

<p>Lastly, three of the vowels (Y, O and I) were not previously displayed, and thus have no corresponding element. These form the <b>enter</b> selection:

<script>

enterAnimation(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "element₀", children: [{type: "key", name: "A", join: 2}]},
      {type: "element", name: "element₁", children: [{type: "key", name: "B"}]},
      {type: "element", name: "element₂", children: [{type: "key", name: "C"}]},
      {type: "element", name: "element₃", children: [{type: "key", name: "D"}]},
      {type: "element", name: "element₄", children: [{type: "key", name: "E", join: -3}]}
    ]}
  ]},
  {type: "function", name: "function", children: [
    {type: "array", name: "array", children: [
      {type: "data", name: "Y", children: [{type: "key", name: "Y"}]},
      {type: "data", name: "E", children: [{type: "key", name: "E"}]},
      {type: "data", name: "A", children: [{type: "key", name: "A"}]},
      {type: "data", name: "O", children: [{type: "key", name: "O"}]},
      {type: "data", name: "I", children: [{type: "key", name: "I"}]}
    ]}
  ]},
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "placeholder₀", children: [{type: "data", name: "Y"}]},
      {type: "null", name: "null"},
      {type: "null", name: "null"},
      {type: "element", name: "placeholder₁", children: [{type: "data", name: "O"}]},
      {type: "element", name: "placeholder₂", children: [{type: "data", name: "I"}]}
    ]}
  ]},
  24 * 5
);

</script>

<aside>An enter selection is typically transient; it is immediately replaced with a normal selection when you call enter.append or enter.insert.</aside>

<p>While update and exit are normal selections, enter is a subclass of selection. This is necessary because it represents elements that <i>do not yet exist</i>. An enter selection contains placeholders rather than DOM elements; these placeholders are simply objects with a <code>__data__</code> property. The implementation of <a href="https://github.com/mbostock/d3/blob/master/src/selection/enter-select.js">enter.select</a> is then specialized such that nodes are inserted into the group’s parent, replacing the placeholder. This is why it is critical to call selectAll prior to a data join: it establishes the parent for entering elements.

<h2><a href="#enter-update" name="enter-update">#</a>Merging Enter & Update</h2>

<p>The <a href="http://bl.ocks.org/mbostock/3808218">general update pattern</a> with a data join appends entering element and removes exiting elements, while modifying dynamic attributes, styles and other properties of updating elements. Often, there’s overlap between properties of updating and entering elements.

<p>To reduce duplicate code, enter.append has a convenient side-effect: it replaces null elements in the update selection with the newly-created elements from the enter selection. Thus, after enter.append, the update selection is modified to contain both entering and updating elements. The update selection subsequently contains all currently-displayed elements:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "element₀", children: [{type: "data", name: "A"}]},
      {type: "element", name: "element₄", children: [{type: "data", name: "E"}]},
      {type: "element", name: "element₅", children: [{type: "data", name: "I"}]},
      {type: "element", name: "element₆", children: [{type: "data", name: "O"}]},
      {type: "element", name: "element₇", children: [{type: "data", name: "U"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p>With the selection once again consistent with the document, the life-cycle of the data join is complete.

<h3 style="margin-top:8em;">Further Reading</h3>

<p>I hope you found this post informative. If you found parts unclear or confusing, or if you have followup questions or other feedback, please let me know via <a href="https://twitter.com/mbostock">Twitter</a> or <a href="https://news.ycombinator.com">Hacker News</a>. If you want to continue learning about selections, <a href="https://github.com/mbostock/d3/tree/master/src/selection/">browsing D3’s source</a> is an invigorating way to test your understanding. Here are several excellent talks and tutorials by others:

<ul>
  <li><a href="http://alignedleft.com/tutorials/d3/binding-data/">Binding Data</a> by Scott Murray
  <li><a href="http://www.rvl.io/annaps/d3-journey-to-the-source/">Journey to the Source</a> by Anna Powell-Smith
  <li><a href="http://macwright.org/presentations/dcjq/">A Fun, Difficult Introduction to D3</a> by Tom MacWright
</ul>

<footer>
  <aside>April 12, 2013</aside>
  <a href="../" rel="author">Mike Bostock</a>
</footer>

<script src="../highlight.min.js"></script>
