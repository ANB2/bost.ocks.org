<!DOCTYPE html>
<meta charset="utf-8">
<title>How Selections Work</title>
<style>

@import url(../style.css?20121227);

.link,
.node rect {
  fill: none;
  stroke: black;
  stroke-width: 1.5px;
}

.node rect {
  fill: white;
}

.link.to-data {
  stroke: #ddd;
}

.node.array rect {
  stroke: #636363;
}

.node.element rect,
.node.null rect {
  stroke: none;
}

.node.null rect {
  fill: none;
}

.node.null text {
  fill: #777;
}

.node.selection rect {
  stroke: #e6550d;
}

.node.data rect {
  fill: #eee;
  stroke: none;
}

.link.to-null {
  stroke-opacity: .5;
  stroke-dasharray: .5,3.5;
  stroke-linecap: round;
}

</style>

<header>
  <aside>April 9, 2013</aside>
  <a href="../" rel="author">Mike Bostock</a>
</header>

<h1>How Selections Work</h1>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

function tree(root, outerHeight) {
  var margin = {top: 0, right: 440, bottom: 0, left: 40},
      width = 960 - margin.right,
      height = outerHeight - margin.top - margin.bottom,
      step = 120;

  var tree = d3.layout.tree()
      .size([height, 1])
      .separation(function() { return 1; });

  var svg = d3.select("body").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .style("margin", "1em 0 1em " + -margin.left + "px");

  var g = svg.append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var nodes = tree.nodes(root);

  var node = g.selectAll(".node")
      .data(nodes)
    .enter().append("g")
      .attr("class", function(d) { return (d.type || "") + " node"; })
      .attr("transform", function(d) { return "translate(" + d.depth * step + "," + d.x + ")"; })

  node.append("text")
      .attr("x", 6)
      .attr("dy", ".32em")
      .text(function(d) { return d.name; })
      .each(function(d) { d.width = this.getComputedTextLength() + 12; });

  node.insert("rect", "text")
      .attr("ry", 6)
      .attr("rx", 6)
      .attr("y", -10)
      .attr("height", 20)
      .attr("width", function(d) { return Math.max(32, d.width); });

  var link = g.selectAll(".link")
      .data(tree.links(nodes))
    .enter().insert("path", ".node")
      .attr("class", function(d) { return "to-" + d.target.type + " from-" + d.source.type + " link";})
      .attr("d", d3.svg.diagonal()
      .source(function(d) { return {y: d.source.depth * step + d.source.width, x: d.source.x}; })
      .target(function(d) { return {y: d.target.depth * step, x: d.target.x}; })
      .projection(function(d) { return [d.y, d.x]; }));

  return svg;
}

</script>

<p>In the past I have <a href="../d3/workshop/">presented</a> <a href="../join/">simplified</a> <a href="http://mbostock.github.io/d3/tutorial/circle.html">descriptions</a> of <a href="https://github.com/mbostock/d3/wiki/Selections">selections</a>, hoping to provide an informative yet quick introduction to D3’s core concept—just enough to get started. This document takes a more comprehensive approach; rather than saying how to <i>use</i> selections, I will instead explain in detail how selections are <i>implemented</i>. This may take longer to read, but it should dispel any magic and reveal everything you need to grasp selections completely.

<h2><a href="#subclass" name="subclass">#</a>A Subclass of Array</h2>

<p>You were probably told that selections are <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array">arrays</a> of <a href="https://developer.mozilla.org/en-US/docs/DOM">DOM</a> <a href="https://developer.mozilla.org/en-US/docs/DOM/element">elements</a>. This is technically true but imprecise. To produce a more accurate definition, let’s start with a simple array of elements and incrementally add detail:

<script>

tree(
  {type: "array", name: "array", children: [
    {type: "element", name: "element"},
    {type: "element", name: "element"},
    {type: "element", name: "element"},
    {type: "element", name: "element"},
    {type: "element", name: "element"},
    {type: "element", name: "element"}
  ]},
  140
);

</script>

<aside>JavaScript doesn’t yet support array subclasses directly, so arrays are subclassed through <a href="http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/">prototype chain injection</a>.</aside>

<p>The first detail is that selections are a <i>subclass</i> of array, not plain arrays. This subclass provides methods to manipulate selected elements, such as <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-attr">setting attributes</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-style">styles</a>.

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "element", name: "element"},
    {type: "element", name: "element"},
    {type: "element", name: "element"},
    {type: "element", name: "element"},
    {type: "element", name: "element"},
    {type: "element", name: "element"}
  ]},
  140
);

</script>

<p>Selections retain native array methods as well, such as <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach">array.forEach</a> and <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach">array.map</a>. However, you won’t often use native methods as D3 provides convenient alternatives, such as <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-each">selection.each</a>. Some native methods are overridden to adapt their behavior to selections (<a href="https://github.com/mbostock/d3/wiki/Selections#wiki-filter">selection.filter</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-sort">selection.sort</a>).

<h2><a href="#group" name="group">#</a>Groups of Elements</h2>

<p>The other reason selections aren’t arrays of elements is that they are actually <i>arrays of arrays</i> of elements; that is, <a href="../nest/">nested</a> arrays of elements. A selection is an array of groups, and each group is an array of related elements (typically siblings).

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [ // TODO parentNode
      {type: "element", name: "element"},
      {type: "element", name: "element"},
      {type: "element", name: "element"}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "element"},
      {type: "element", name: "element"},
      {type: "element", name: "element"},
      {type: "element", name: "element"}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "element"},
      {type: "element", name: "element"},
      {type: "element", name: "element"}
    ]}
  ]},
  240
);

</script>

<p>If you are familiar with jQuery, D3’s nested selections may be surprising: why the extra complexity over flat selections? D3 is <i>data-driven</i> documents, and nesting is essential to map hierarchical data to hierarchical DOM elements. This will become more clear in a moment when we get to data joins, but for now consider this simple two-dimensional data structure:

<pre><code>var matrix = [
  [ 0,  1,  2,  3],
  [ 4,  5,  6,  7],
  [ 8,  9, 10, 11],
  [12, 13, 14, 15],
];</code></pre>

<p>To create a <a href="https://developer.mozilla.org/en-US/docs/HTML/Element/table">table</a> from this matrix with matching structure, we need four <a href="https://developer.mozilla.org/en-US/docs/HTML/Element/tr">tr</a> elements, each containing four <a href="https://developer.mozilla.org/en-US/docs/HTML/Element/td">td</a> elements. A data join can enter the rows:

<pre><code>var tr = table.selectAll("tr")
    .data(matrix)
  .enter().append("tr");</code></pre>

<p>Yet to create the cells without resorting to manual iteration, we need a nested data join. Instead of a single flat join for all 16 numbers, it is more convenient to express separate data joins for each row, joining only the four numbers for that row. D3 allows data to be specified as a function which is computed for each group in the selection (here, each row). The identity function dereferences the nested array, returning the four numbers for each row:

<pre><code>var td = tr.selectAll("td")
    .data(function(d) { return d; })
  .enter().append("td");</code></pre>

<p>Nested selections also have the advantage that indexes are within-group rather than within-selection. So, the index of each cell of each row is always zero, one, two and three. To color the first column red, you can say:

<pre><code>td.style("color", function(d, i) { return i ? null : "red"; });</code></pre>

<p>Groups also define the parent node, which determines where entering elements in a data join are appended. In the nested join above, the td selection has four groups, and each group’s parent node is one of the four tr elements. The entering td elements are therefore appended to the appropriate tr element. (If this is confusing, we’ll revisit this topic when we get to data joins.)

<p>In many cases, you don’t need nested selections. So what does a “flat” D3 selection look like, as returned by <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_selectAll">d3.selectAll</a>? A selection with only one group:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [ // TODO parentNode
      {type: "element", name: "element"},
      {type: "element", name: "element"},
      {type: "element", name: "element"},
      {type: "element", name: "element"},
      {type: "element", name: "element"},
      {type: "element", name: "element"}
    ]}
  ]},
  140
);

</script>

<aside>The parent node for selections returned by d3.select and d3.selectAll is the root <a href="https://developer.mozilla.org/en-US/docs/DOM/document.documentElement">document element</a>.</aside>

<p>Or, even simpler, for a singleton selection as returned by <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_select">d3.select</a>:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [ // TODO parentNode
      {type: "element", name: "element"}
    ]}
  ]},
  30
);

</script>

<p>This is why you’ll sometimes see <code>selection[0][0]</code> to refer to the first node, although generally it’s better to use <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-node">selection.node</a>.

<h2><a href="#sparse" name="sparse">#</a>Sparse Arrays</h2>

<p>Selections can contain null elements. This allows <i>sparse</i> selections which are missing elements. Most commonly this applies during a data-join, where the <i>enter</i>, <i>update</i> and <i>exit</i> selections are derived from an input selection and an array (or multiple arrays) of data. The <i>enter</i> and <i>update</i> selections match the indexes of the data; element <i>i</i> in the <i>enter</i> selection corresponds to datum <i>i</i>; if element <i>i</i> is in the <i>update</i> selection instead, element <i>i</i> in the <i>enter</i> selection is null.

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group", children: [
      {type: "element", name: "element"},
      {name: "null", type: "null"},
      {name: "null", type: "null"}
    ]},
    {type: "array", name: "group", children: [
      {name: "null", type: "null"},
      {type: "element", name: "element"},
      {type: "element", name: "element"}
    ]},
    {type: "array", name: "group", children: [
      {type: "element", name: "element"},
      {type: "element", name: "element"},
      {name: "null", type: "null"}
    ]}
  ]},
  220
);

</script>
<h2><a href="#data" name="data">#</a>Elements and Data</h2>

<p>Perhaps surprisingly, data is <i>not</i> a property of selections; data is a property of elements. This means that when you bind data a selection, the data is stored in the DOM rather than in the selection. In this way selections are transient: you can reselect elements from the DOM and they will retain whatever data was previously bound to them.

<p>Note, however, that selection.select propagates data from parent to child, which can overwrite data that was previously bound.

<p>Elements can have data bound to them. This is stored in <code>__data__</code> and so isn’t strictly part of the selection; if you reselect elements from the document, they will retain whatever data was bound to them previously.

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "element", name: "element", children: [{type: "data", name: "data"}]},
    {type: "element", name: "element", children: [{type: "data", name: "data"}]},
    {type: "element", name: "element", children: [{type: "data", name: "data"}]},
    {type: "element", name: "element", children: [{type: "data", name: "data"}]},
    {type: "element", name: "element", children: [{type: "data", name: "data"}]},
    {type: "element", name: "element", children: [{type: "data", name: "data"}]}
  ]},
  140
);

</script>

<p>And of course, not every element may have data associated with it.

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "element", name: "element", children: [{type: "data", name: "data"}]},
    {type: "element", name: "element"},
    {type: "element", name: "element"},
    {type: "element", name: "element", children: [{type: "data", name: "data"}]},
    {type: "element", name: "element"},
    {type: "element", name: "element", children: [{type: "data", name: "data"}]}
  ]},
  140
);

</script>

<p>There are two forms of data-join, by <i>index</i> and by <i>key</i>. A data-join by index occurs when you call selection.data with only one argument; <i>i.e.</i>, you specify the data but not the key function. A data-join by key occurs when you specify two arguments, the second being the key function.

<p>Consider the more general join by key first. The key function is invoked for each element in the selection, and for each datum in the data. The key function returns a string key. If the key for an element matches the key for a datum, the element and the datum are considered “joined” and the element is put in the <i>update</i> selection.

<p>The <i>update</i> selection is simply the return value of selection.data. Why not an explicit update method? Well, for brevity.

<p>The <i>enter</i> selection contains <i>placeholder</i> nodes. What are these? Furthermore, the <i>enter</i> selection is not a full d3.selection, and only supports a subset of methods. Generally, an enter selection should only exist transiently; you are expected to call enter.append or enter.insert to immediately create a full selection.

<footer>
  <aside>April 9, 2013</aside>
  <a href="../" rel="author">Mike Bostock</a>
</footer>

<script src="../highlight.min.js"></script>
