<!DOCTYPE html>
<meta charset="utf-8">
<title>How Selections Work</title>
<style>

@import url(../style.css?20121227);

.link,
.node rect {
  fill: none;
  stroke: #636363;
  stroke-width: 1.5px;
}

.node rect {
  fill: white;
}

.link.to-data {
  stroke: #ddd;
}

.node.array rect {
  stroke: #636363;
}

.link.to-element {
  stroke: #bdbdbd;
}

.node.element rect {
  fill: #bdbdbd;
  stroke: none;
}

.node.null rect {
  stroke: none;
}

.node.null text {
  fill: #636363;
}

.node.function rect {
  stroke: #3182bd;
}

.node.selection rect {
  stroke: #e6550d;
}

.node.data rect {
  fill: #d9d9d9;
  stroke: none;
}

.link.to-key {
  stroke: #a1d99b;
}

.node.key rect {
  fill: #a1d99b;
  stroke: none;
}

.link.to-null {
  stroke-opacity: .5;
  stroke-dasharray: .5,3.5;
  stroke-linecap: round;
}

</style>

<header>
  <aside>April 9, 2013</aside>
  <a href="../" rel="author">Mike Bostock</a>
</header>

<h1>How Selections Work</h1>

<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

function tree(leftRoot, rightRoot, outerHeight) {
  if (arguments.length < 3) outerHeight = rightRoot, rightRoot = null;

  var margin = {top: 0, right: 40, bottom: 0, left: 40},
      width = 720,
      height = outerHeight - margin.top - margin.bottom,
      step = 100;

  var tree = d3.layout.tree()
      .size([height, 1])
      .separation(function() { return 1; });

  var svg = d3.select("body").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .style("margin", "1em 0 1em " + -margin.left + "px");

  var g = svg.selectAll("g")
      .data([].concat(
        leftRoot ? {nodes: tree.nodes(leftRoot)} : [],
        rightRoot ? {nodes: tree.nodes(rightRoot).map(flip), flipped: true} : []
      ))
    .enter().append("g")
      .attr("transform", function(d) {
        return "translate(" + (!!d.flipped * width + margin.left) + "," + margin.top + ")";
      });

  var node = g.selectAll(".node")
      .data(function(d) { return d.nodes; })
    .enter().append("g")
      .attr("class", function(d) { return (d.type || "") + " node"; })
      .attr("transform", function(d) { return "translate(" + d.depth * step + "," + d.x + ")"; })

  node.append("text")
      .attr("x", 6)
      .attr("dy", ".35em")
      .text(function(d) { return d.name; })
      .each(function(d) { d.width = Math.max(32, this.getComputedTextLength() + 12); })
    .filter(function(d) { return d.flipped; })
      .attr("x", function(d) { return 6 - d.width; });

  node.insert("rect", "text")
      .attr("ry", 6)
      .attr("rx", 6)
      .attr("y", -10)
      .attr("height", 20)
      .attr("width", function(d) { return d.width; })
    .filter(function(d) { return d.flipped; })
      .attr("x", function(d) { return -d.width; });

  var link = g.selectAll(".link")
      .data(function(d) { return tree.links(d.nodes); })
    .enter().insert("path", ".node")
      .attr("class", function(d) { return "to-" + d.target.type + " from-" + d.source.type + " link";})
      .attr("d", d3.svg.diagonal()
      .source(function(d) { return {y: d.source.depth * step + (d.source.flipped ? -1 : +1) * d.source.width, x: d.source.x}; })
      .target(function(d) { return {y: d.target.depth * step, x: d.target.x}; })
      .projection(function(d) { return [d.y, d.x]; }));

  function flip(d) {
    d.depth *= -1;
    d.flipped = true;
    return d;
  }

  return svg;
}

</script>

<p>In the past I have <a href="../d3/workshop/">presented</a> <a href="../join/">simplified</a> <a href="http://mbostock.github.io/d3/tutorial/circle.html">descriptions</a> of <a href="https://github.com/mbostock/d3/wiki/Selections">selections</a>, hoping to provide an informative yet quick introduction to D3’s core concept—just enough to get started. This document takes a more comprehensive approach; rather than saying how to <i>use</i> selections, I will instead explain how selections are <i>implemented</i>. This may take longer to read, but it should dispel any magic and cover everything you need to grasp selections completely.

<h2><a href="#subclass" name="subclass">#</a>A Subclass of Array</h2>

<p>You were probably told that selections are <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array">arrays</a> of <a href="https://developer.mozilla.org/en-US/docs/DOM">DOM</a> <a href="https://developer.mozilla.org/en-US/docs/DOM/element">elements</a>. This is technically true but imprecise. To craft a more accurate definition, let’s start with a simple array of elements and incrementally add detail:

<script>

tree(
  {type: "array", name: "array", children: [
    {type: "element", name: "element₀"},
    {type: "element", name: "element₁"},
    {type: "element", name: "element₂"},
    {type: "element", name: "element₃"},
    {type: "element", name: "element₄"},
    {type: "element", name: "element₅"}
  ]},
  24 * 6
);

</script>

<aside>JavaScript doesn’t yet support array subclasses directly, so arrays are subclassed through <a href="http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/">prototype chain injection</a>.</aside>

<p>The first bit is that selections are a <i>subclass</i> of array, not plain arrays. This subclass provides methods to manipulate selected elements, such as <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-attr">setting attributes</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-style">styles</a>.

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "element", name: "element₀"},
    {type: "element", name: "element₁"},
    {type: "element", name: "element₂"},
    {type: "element", name: "element₃"},
    {type: "element", name: "element₄"},
    {type: "element", name: "element₅"}
  ]},
  24 * 6
);

</script>

<p>Selections retain native array methods as well, such as <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach">array.forEach</a> and <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach">array.map</a>. However, you won’t often use native methods as D3 provides convenient alternatives, such as <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-each">selection.each</a>. A few native methods are overridden to adapt their behavior to selections (<a href="https://github.com/mbostock/d3/wiki/Selections#wiki-filter">selection.filter</a> and <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-sort">selection.sort</a>).

<h2><a href="#group" name="group">#</a>Groups of Elements</h2>

<p>The other reason selections aren’t arrays of elements is that they are actually <i>arrays of arrays</i> of elements. A selection is an array of groups, and each group is an array of elements. For example, <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_selectAll">d3.selectAll</a> returns a selection with a single group containing the selected elements:

<aside>While the selection is a subclass of array, groups are plain arrays. They do, however, have a <code>parentNode</code> property which stores the shared ancestor of the group’s elements.</aside>

<pre><code>d3.selectAll("tr")</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "tr₀"},
      {type: "element", name: "tr₁"},
      {type: "element", name: "tr₂"},
      {type: "element", name: "tr₃"}
    ]}
  ]},
  24 * 4
);

</script>

<p>Likewise, for a single-element selection as returned by <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-d3_select">d3.select</a>:

<!-- ; that is, <a href="../nest/">nested</a> arrays of elements -->

<aside>This is why you’ll sometimes see <code>selection[0][0]</code> to refer to the first node, although for reasons that will soon be apparent it’s better to use <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-node">selection.node</a>.</aside>

<pre><code>d3.select("table")</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "table₀"}
    ]}
  ]},
  24 * 1
);

</script>

<p>Selections returned by d3.select and d3.selectAll only have a single group, so the only way you to get a selection with multiple groups is selectAll followed by <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-selectAll">selectAll</a>. So if you select the rows and then select the rows’ cells, you now have a group of sibling cells for each row:

<!-- <p>The tr elements have child nodes:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "tr₀", children: [
        {type: "element", name: "td₀"},
        {type: "element", name: "td₁"},
        {type: "element", name: "td₂"},
        {type: "element", name: "td₃"}
      ]},
      {type: "element", name: "tr₁", children: [
        {type: "element", name: "td₀"},
        {type: "element", name: "td₁"},
        {type: "element", name: "td₂"},
        {type: "element", name: "td₃"}
      ]},
      {type: "element", name: "tr₂", children: [
        {type: "element", name: "td₀"},
        {type: "element", name: "td₁"},
        {type: "element", name: "td₂"},
        {type: "element", name: "td₃"}
      ]},
      {type: "element", name: "tr₃", children: [
        {type: "element", name: "td₀"},
        {type: "element", name: "td₁"},
        {type: "element", name: "td₂"},
        {type: "element", name: "td₃"}
      ]}
    ]}
  ]},
  24 * 16
);

</script> -->

<pre><code>d3.selectAll("tr").selectAll("td")</code></pre>

<aside>Although this selection’s groups all have four elements, in general a selection’s groups can have different numbers of elements. Some groups might even be empty!</aside>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "td₀"},
      {type: "element", name: "td₁"},
      {type: "element", name: "td₂"},
      {type: "element", name: "td₃"}
    ]},
    {type: "array", name: "group₁", children: [
      {type: "element", name: "td₀"},
      {type: "element", name: "td₁"},
      {type: "element", name: "td₂"},
      {type: "element", name: "td₃"}
    ]},
    {type: "array", name: "group₂", children: [
      {type: "element", name: "td₀"},
      {type: "element", name: "td₁"},
      {type: "element", name: "td₂"},
      {type: "element", name: "td₃"}
    ]},
    {type: "array", name: "group₃", children: [
      {type: "element", name: "td₀"},
      {type: "element", name: "td₁"},
      {type: "element", name: "td₂"},
      {type: "element", name: "td₃"}
    ]}
  ]},
  24 * 16
);

</script>

<p>With selection.selectAll, every element in the old selection becomes a group in the new selection. Each group contains the matching descendant elements for the corresponding previously-selected element. So, if you called selectAll a third time (!), you’d now get a selection with sixteen groups:

<pre><code>d3.selectAll("tr").selectAll("td").selectAll("span")</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₁", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₂", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₃", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₄", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₅", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₆", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₇", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₈", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₉", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₁₀", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₁₁", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₁₂", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₁₃", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₁₄", children: [{type: "element", name: "span₀"}]},
    {type: "array", name: "group₁₅", children: [{type: "element", name: "span₀"}]}
  ]},
  24 * 16
);

</script>

<p>It’s only selectAll that has this special behavior. Select, in contrast, preserves the grouping:

<pre><code>d3.selectAll("tr").selectAll("td").select("span")</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "span₀"},
      {type: "element", name: "span₁"},
      {type: "element", name: "span₂"},
      {type: "element", name: "span₃"}
    ]},
    {type: "array", name: "group₁", children: [
      {type: "element", name: "span₀"},
      {type: "element", name: "span₁"},
      {type: "element", name: "span₂"},
      {type: "element", name: "span₃"}
    ]},
    {type: "array", name: "group₂", children: [
      {type: "element", name: "span₀"},
      {type: "element", name: "span₁"},
      {type: "element", name: "span₂"},
      {type: "element", name: "span₃"}
    ]},
    {type: "array", name: "group₃", children: [
      {type: "element", name: "span₀"},
      {type: "element", name: "span₁"},
      {type: "element", name: "span₂"},
      {type: "element", name: "span₃"}
    ]}
  ]},
  24 * 16
);

</script>

<p>Most of the time, you can ignore that selections are grouped. When you pass a function to <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-attr">attr</a> or <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-style">style</a>, the function is called for each element, so the only difference with grouping is that the second argument to your function (<code>i</code>) is the within-group index rather than the within-selection index. The killer feature for nesting is the behavior of <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>, which allows you to define data per-group, and more easily create hierarchical DOM elements from hierarchical data. We’ll revisit this topic when we get to data joins.

<!-- <h3>Why Nested?</h3>

<p>If you are familiar with jQuery, D3’s nested selections may be surprising: why the extra complexity over flat selections? D3 is <i>data-driven</i> documents, and nesting is essential to map hierarchical data to hierarchical DOM elements. This will become more clear in a moment when we get to data joins, but for now consider this simple two-dimensional data structure:

<pre><code>var matrix = [
  [ 0,  1,  2,  3],
  [ 4,  5,  6,  7],
  [ 8,  9, 10, 11],
  [12, 13, 14, 15],
];</code></pre>

<p>To create a <a href="https://developer.mozilla.org/en-US/docs/HTML/Element/table">table</a> from this matrix with matching structure, we need four <a href="https://developer.mozilla.org/en-US/docs/HTML/Element/tr">tr</a> elements, each containing four <a href="https://developer.mozilla.org/en-US/docs/HTML/Element/td">td</a> elements. A data join can enter the rows:

<aside>You can inspect the <code>parentNode</code> of each group in a selection using your browser’s JavaScript console.</aside>

<p>Yet to create the cells without resorting to manual iteration, we need a nested data join. Instead of a single flat join for all 16 numbers, it is more convenient to express separate data joins for each row, joining only the four numbers for that row. D3 allows data to be specified as a function which is computed for each group in the selection (here, each row). The identity function dereferences the nested array, returning the four numbers for each row:

<aside>The parent node for selections returned by d3.select and d3.selectAll is the root <a href="https://developer.mozilla.org/en-US/docs/DOM/document.documentElement">document element</a>.</aside>

<p>Nested selections also have the advantage that indexes are within-group rather than within-selection. For example, the first cell of each row is always index zero. And groups define the parent node, which determines where entering elements in a data join are appended. In the nested join above, the td selection has four groups, and each group’s parent node is one of the four tr elements. The entering td elements are therefore appended to the appropriate tr element. -->

<h2><a href="#sparse" name="sparse">#</a>Sparse Arrays</h2>

<p>Sometimes it’s useful to derive a new selection from the current selection while retaining the existing grouping. An example of this is <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-append">selection.append</a>, which appends a new element to each selected element. For example, if the document has four sections, and we select them all:

<pre><code>d3.selectAll("section")</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "section₀"},
      {type: "element", name: "section₁"},
      {type: "element", name: "section₂"},
      {type: "element", name: "section₃"}
    ]}
  ]},
  24 * 4
);

</script>

<p>If we then append a paragraph element to each section, the returned selection still has only a single group containing four elements:

<pre><code>d3.selectAll("section").append("p")</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀"},
      {type: "element", name: "p₁"},
      {type: "element", name: "p₂"},
      {type: "element", name: "p₃"}
    ]}
  ]},
  24 * 4
);

</script>

<p>The <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-select">selection.select</a> method functions the same way. In fact, as you can see from the source code, <a href="https://github.com/mbostock/d3/blob/master/src/selection/append.js">append</a> and <a href="https://github.com/mbostock/d3/blob/master/src/selection/insert.js">insert</a> are just simple wrappers on top of select! Yet there’s an important difference: while append creates a new element, select must find a matching element. Sometimes, there is no such element; in this case, the returned selection has null elements. For example, if only the first and last sections have asides, we might see:

<pre><code>d3.selectAll("section").select("aside")</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "aside₀"},
      {type: "null", name: "null"},
      {type: "null", name: "null"},
      {type: "element", name: "aside₃"}
    ]}
  ]},
  24 * 4
);

</script>

<p>Null elements are ignored for most operations. For example, D3 skips over any null elements when applying styles and attributes. Yet null elements serve an important purpose in preserving the grouped structure of a selection (and the within-group index). This is critical when handling the result of a data join, which splits a selection into three parts: <i>enter</i>, <i>update</i> and <i>exit</i>. These three selections share the original selection’s structure, with null elements in-between.

<h2><a href="#data" name="data">#</a>Bound to Data</h2>

<p>Perhaps surprisingly, data is <i>not</i> a property of the selection, but a property of its elements. This means that when you bind data a selection, the data is stored in the DOM rather than in the selection: data is assigned to the <code>__data__</code> property of each element. If an element lacks this property, the associated datum is undefined. Selections are therefore transient: you can reselect elements from the DOM and they will retain whatever data was previously bound to them.

<aside>To verify that data is a property of elements, see <a href="https://github.com/mbostock/d3/blob/master/src/selection/datum.js">selection.datum</a>’s implementation.</aside>

<p>Data is bound to elements one of several ways:<ul>

  <li>Inherited from a parent via append, insert, or select.
  <li>Assigned to individual elements via <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-datum">selection.datum</a>.
  <li>Joined to groups of elements via <a href="https://github.com/mbostock/d3/wiki/Selections#wiki-data">selection.data</a>.

</ul>

<p>There’s no reason to set the <code>__data__</code> property directly when you can use selection.datum, but doing so illustrates how data binding is implemented. You might also find this knowledge useful when inspecting selections in your browser’s developer tools; <code>$0.__data__</code> shows the data bound to the inspected element. To bind the number 42 to the body element by hand:

<pre><code>document.body.__data__ = 42;</code></pre>

<script>

tree(
  {type: "element", name: "body₀", children: [
    {type: "data", name: "42"}
  ]},
  24 * 1
);

</script>

<p>The idiomatic equivalent is to select the body and call datum:

<pre><code>d3.select("body").datum(42)</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "body₀", children: [
        {type: "data", name: "42"}
      ]}
    ]}
  ]},
  24 * 1
);

</script>

<p>If we now append an element to the body, the child automatically inherits data from the parent:

<pre><code>d3.select("body").datum(42).append("h1")</code></pre>

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "h1₀", children: [
        {type: "data", name: "42"}
      ]}
    ]}
  ]},
  24 * 1
);

</script>

<p>And that brings us to the last method: the mysterious data join. But before we can achieve enlightenment with joins, we first need to answer a more existential question: What is data?

<h2>Arrays of Data</h2>

<p>To explain the data join, we need a visual representation for data. Data in D3 is represented as a plain array of values:

<script>

tree(
  null,
  {type: "array", name: "data", children: [
    {type: "data", name: "4"},
    {type: "data", name: "5"},
    {type: "data", name: "18"},
    {type: "data", name: "23"},
    {type: "data", name: "42"}
  ]},
  24 * 5
);

</script>

<p>The data can be expressed as a function:

<script>

tree(
  null,
  {type: "function", name: "function", children: [
    {type: "array", name: "data", children: [
      {type: "data", name: "4"},
      {type: "data", name: "5"},
      {type: "data", name: "18"},
      {type: "data", name: "23"},
      {type: "data", name: "42"}
    ]}
  ]},
  24 * 5
);

</script>

<h2>Keys to the Kingdom</h2>

<p>Before we can compute the join, we must first compute keys for the data:

<script>

tree(
  null,
  {type: "function", name: "function", children: [
    {type: "array", name: "data", children: [
      {type: "data", name: "4", children: [{type: "key", name: "key₀"}]},
      {type: "data", name: "5", children: [{type: "key", name: "key₁"}]},
      {type: "data", name: "18", children: [{type: "key", name: "key₂"}]},
      {type: "data", name: "23", children: [{type: "key", name: "key₃"}]},
      {type: "data", name: "42", children: [{type: "key", name: "key₄"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p>And likewise keys for the elements:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀", children: [{type: "key", name: "key₀"}]},
      {type: "element", name: "p₁", children: [{type: "key", name: "key₁"}]},
      {type: "element", name: "p₂", children: [{type: "key", name: "key₂"}]},
      {type: "element", name: "p₃", children: [{type: "key", name: "key₃"}]},
      {type: "element", name: "p₄", children: [{type: "key", name: "key₄"}]}
    ]}
  ]},
  null,
  24 * 5
);

</script>

<p>And then pair up matching keys:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀", children: [{type: "key", name: "key₀"}]},
      {type: "element", name: "p₁", children: [{type: "key", name: "key₁"}]},
      {type: "element", name: "p₂", children: [{type: "key", name: "key₂"}]},
      {type: "element", name: "p₃", children: [{type: "key", name: "key₃"}]},
      {type: "element", name: "p₄", children: [{type: "key", name: "key₄"}]}
    ]}
  ]},
  {type: "function", name: "function", children: [
    {type: "array", name: "data", children: [
      {type: "data", name: "4", children: [{type: "key", name: "key₀"}]},
      {type: "data", name: "5", children: [{type: "key", name: "key₁"}]},
      {type: "data", name: "18", children: [{type: "key", name: "key₂"}]},
      {type: "data", name: "23", children: [{type: "key", name: "key₃"}]},
      {type: "data", name: "42", children: [{type: "key", name: "key₄"}]}
    ]}
  ]},
  24 * 5
);

</script>

<p>Which can get quite complicated:

<script>

tree(
  {type: "selection", name: "selection", children: [
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀", children: [{type: "key", name: "key₀"}]},
      {type: "element", name: "p₁", children: [{type: "key", name: "key₁"}]},
      {type: "element", name: "p₂", children: [{type: "key", name: "key₂"}]},
      {type: "element", name: "p₃", children: [{type: "key", name: "key₃"}]}
    ]},
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀", children: [{type: "key", name: "key₀"}]},
      {type: "element", name: "p₁", children: [{type: "key", name: "key₁"}]},
      {type: "element", name: "p₂", children: [{type: "key", name: "key₂"}]},
      {type: "element", name: "p₃", children: [{type: "key", name: "key₃"}]}
    ]},
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀", children: [{type: "key", name: "key₀"}]},
      {type: "element", name: "p₁", children: [{type: "key", name: "key₁"}]},
      {type: "element", name: "p₂", children: [{type: "key", name: "key₂"}]},
      {type: "element", name: "p₃", children: [{type: "key", name: "key₃"}]}
    ]},
    {type: "array", name: "group₀", children: [
      {type: "element", name: "p₀", children: [{type: "key", name: "key₀"}]},
      {type: "element", name: "p₁", children: [{type: "key", name: "key₁"}]},
      {type: "element", name: "p₂", children: [{type: "key", name: "key₂"}]},
      {type: "element", name: "p₃", children: [{type: "key", name: "key₃"}]}
    ]}
  ]},
  {type: "function", name: "function", children: [
    {type: "array", name: "data", children: [
      {type: "data", name: "4", children: [{type: "key", name: "key₀"}]},
      {type: "data", name: "5", children: [{type: "key", name: "key₁"}]},
      {type: "data", name: "18", children: [{type: "key", name: "key₂"}]},
      {type: "data", name: "23", children: [{type: "key", name: "key₃"}]}
    ]},
    {type: "array", name: "data", children: [
      {type: "data", name: "4", children: [{type: "key", name: "key₀"}]},
      {type: "data", name: "5", children: [{type: "key", name: "key₁"}]},
      {type: "data", name: "18", children: [{type: "key", name: "key₂"}]},
      {type: "data", name: "23", children: [{type: "key", name: "key₃"}]}
    ]},
    {type: "array", name: "data", children: [
      {type: "data", name: "4", children: [{type: "key", name: "key₀"}]},
      {type: "data", name: "5", children: [{type: "key", name: "key₁"}]},
      {type: "data", name: "18", children: [{type: "key", name: "key₂"}]},
      {type: "data", name: "23", children: [{type: "key", name: "key₃"}]}
    ]},
    {type: "array", name: "data", children: [
      {type: "data", name: "4", children: [{type: "key", name: "key₀"}]},
      {type: "data", name: "5", children: [{type: "key", name: "key₁"}]},
      {type: "data", name: "18", children: [{type: "key", name: "key₂"}]},
      {type: "data", name: "23", children: [{type: "key", name: "key₃"}]}
    ]}
  ]},
  24 * 16
);

</script>

<h2>Enter, Update and Exit</h2>

<p>We only have to rebind new data when we perform an operation that regroups the selection.

<p>There are two forms of data-join, by <i>index</i> and by <i>key</i>. A data-join by index occurs when you call selection.data with only one argument; <i>i.e.</i>, you specify the data but not the key function. A data-join by key occurs when you specify two arguments, the second being the key function.

<p>Consider the more general join by key first. The key function is invoked for each element in the selection, and for each datum in the data. The key function returns a string key. If the key for an element matches the key for a datum, the element and the datum are considered “joined” and the element is put in the <i>update</i> selection.

<p>The <i>update</i> selection is simply the return value of selection.data. Why not an explicit update method? Well, for brevity.

<p>The <i>enter</i> selection contains <i>placeholder</i> nodes. What are these? Furthermore, the <i>enter</i> selection is not a full d3.selection, and only supports a subset of methods. Generally, an enter selection should only exist transiently; you are expected to call enter.append or enter.insert to immediately create a full selection.

<footer>
  <aside>April 9, 2013</aside>
  <a href="../" rel="author">Mike Bostock</a>
</footer>

<script src="../highlight.min.js"></script>
